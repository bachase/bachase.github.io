<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>bachase notes</title>
<link>https://bachase.github.io/</link>
<atom:link href="https://bachase.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description>bachase&#39;s notes on things he&#39;s learning about</description>
<generator>quarto-1.8.25</generator>
<lastBuildDate>Wed, 01 Oct 2025 00:00:00 GMT</lastBuildDate>
<item>
  <title>Profiling Quantum Compilers: pyqpanda</title>
  <link>https://bachase.github.io/posts/profiling-quantum-compilers-pyqpanda/</link>
  <description><![CDATA[ 




<p>For the next post in the quantum compiler profiling <a href="../../posts/profiling-quantum-compilers/">series</a>, we will focus on pyqpanda3 version 0.3.1. <a href="https://qcloud.originqc.com.cn/document/qpanda-3/index.html">pyqpanda3</a> is “high-performance quantum programming framework that enhances quantum computing efficiency through optimized circuit compilation, an advanced instruction stream format (OriginBIS), and hardware-aware execution strategies” developed by <a href="https://originqc.com.cn/">OriginQ</a>. Although freely available as a python package, it is closed source with the python code shipping compiled shared object files for supported platforms. I’ve included it because it is very fast and performant on benchmarks, probably thanks to its internal represenation of quantum circuits as a compact binary instruction stream. There are more details in <a href="https://arxiv.org/abs/2504.02455">this</a> arXiv paper from the OriginQ team, but even then, only at a high-level.</p>
<section id="overview" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>As we did the <a href="../../posts/profiling-quantum-compilers-qiskit">last</a> <a href="../../posts/profiling-quantum-compilers-pytket">times</a>, we begin with a top-level view of the compilation. This took a total of 560 milliseconds. Remember, we are sampling 100 times per second, so this is only 56 samples. You can inspect this function-aggregated view in speedscope <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fnative.functionagg.profiles%2Fpyqpanda.profile.json&amp;title=pyqpanda3%20Profile%20FunctionAgg">here</a>.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pyqpanda/pyqpanda_overview.png" class="img-fluid"></p>
<p>The benchmark harness code is below, with the code annotated with the labels in the image above.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> run_pyqpanda(qasm): <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#                             (1)</span></span>
<span id="cb1-2">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> pyqpanda3.intermediate_compiler <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> (</span>
<span id="cb1-3">        convert_qasm_string_to_qprog,</span>
<span id="cb1-4">    )</span>
<span id="cb1-5">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> pyqpanda3.transpilation <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Transpiler</span>
<span id="cb1-6"></span>
<span id="cb1-7">    circuit <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> convert_qasm_string_to_qprog(qasm) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#    (2)</span></span>
<span id="cb1-8">    transpiler <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Transpiler()</span>
<span id="cb1-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> transpiler.transpile(                 <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#    (3)</span></span>
<span id="cb1-10">        circuit,</span>
<span id="cb1-11">        init_mapping<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>{},</span>
<span id="cb1-12">        optimization_level<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>,</span>
<span id="cb1-13">        basic_gates<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RX"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RY"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RZ"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"H"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"CNOT"</span>],</span>
<span id="cb1-14">    )</span></code></pre></div></div>
<p>The bulk of the time is in two spots:</p>
<div class="no-bullets">
<ul>
<li><span class="circle">2</span> [71%, 400ms] in <code>convert_qasm_string_to_qprog</code> parsing the 25K line QASM file into pyqpanda3’s in-memory circuit representation.</li>
<li><span class="circle">3</span> [27%, 150ms] in <code>transpile</code> actually optimizing the circuit.</li>
</ul>
</div>
<p>Not visible is the python import time, which was fairly negligible at 10ms. The overall runtime is almost 4 times faster than the next best <a href="../../posts/profiling-quantum-compilers/#benchmark-summary">compiler benchmarked</a> for this QFT circuit.</p>
<section id="parsing" class="level3">
<h3 class="anchored" data-anchor-id="parsing">Parsing</h3>
<p>pyqpanda3 is quite fast, but it’s notable that it spends more time parsing than transpiling the circuit.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pyqpanda/pyqpanda_parse.png" class="img-fluid"></p>
<p>In the sandwich view above, we see what is likely a hand-built parser + tokenizer. The hierarchy of calls to <span class="circle">1</span> show the parser side, where a program is comprised of statements, which can probably be quantum or classical. Our QASM file is all quantum ones that are gate calls with operands. Below those parsers in <span class="circle">2</span> you can see a call to <code>CompilerQASM::QASMScanner::next</code> that pulls out the next token for the parser.</p>
<p>Under the hood this is using C++ standard library streams for this. For example, the <code>CompilerParser::Scanner::consumeNumberLiteral</code> uses a C++ <a href="https://en.cppreference.com/w/cpp/io/basic_stringstream.html"><code>stringstream</code></a> to read into the number. There is some overhead from streams dealing with <a href="https://en.cppreference.com/w/cpp/locale/locale.html"><code>locales</code></a> (also in <span class="circle">3</span> when calling <code>CompilerParser::Token::toString</code>). Specifically, parsing will have to call locale facets (ctype, numpunct, num_get) to classify characters and handle decimal points/thousands separators that may differ by region. Streams and locales alos have bookkeeping on whitespace and stream state. These can involve a few layers of indirection (via virtual function dispatch) that are a tad heavy for these short parsing calls. I’m nitpicking here, but given QASM has a specification, you might get more performance here with a leaner/purpose-built parser.</p>
</section>
<section id="transpiling" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="transpiling">Transpiling</h3>
<p>Without the source, it’s even harder to tell what is happening with transpilation, but we at least get a hint from the time-ordered view below<sup>1</sup>.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;When writing this section, I decided to re-run the profiler with a higher sampling rate of 400 times per second because the standard 100 times/second had lots of single sample call stack entries that might not’ve been representative. Click <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fpyqpanda.profiles%2Fpyqpanda.400.profile.json">here</a> to view this version in speedscope. Note there was some impact to runtime as a result, but the relative durations of each phase of transpilation is similar and I prefer slightly more detailed callstacks.</p></div></div><p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pyqpanda/pyqpanda_transpile.png" class="img-fluid"></p>
<p>This timeline view zooms in on the transpilation call, which has three main phases</p>
<div class="no-bullets">
<ul>
<li><span class="circle">1</span> [22.5ms] is <code>DAGQCircuit::from_qprog</code>, which converts from a general representation to a DAG circuit, presumably to be a DAG-style IR for the style of circuit optimizations in pyqpanda.</li>
<li><span class="circle">2</span> [66ms] in <code>Transpiler::transpile</code>. I see calls to <code>OptimizationPass::unitary_synthesis</code>. Of note is a final call to <code>DAGQCircuit::batch_insert</code>, which would potentially help performance by modifying the dag all at once at the end, versus doing it piece by piece as its walked</li>
<li><span class="circle">3</span> [280ms] in <code>BasicTranslationPass::merage_and_translation</code> (typo is in the original binary). Here, I see calls like <code>translate_cz_to_cx_h</code>, <code>translate_oracle_to_cz_u4</code>, <code>translate_u3_to_rx_rz</code>. I also see a stack of calls for <code>TwoQubitBasisDecomposer</code> that has a <code>Weyl</code> decomposition. All of these are repeated a few times, suggesting some looping pass.</li>
</ul>
</div>
<p>Unfortunately, its hard to backout the overall strategy here. But it looks like some standard translation/substitution rules, and then some consolidation followed by some two-qubit decomposition/synthesis before repeating. The documentation states for this highest level optimization configuration, “advanced optimizations are performed, including matrix optimization, two-qubit gate cancellation, and single-qubit gate merging.”</p>
</section>
<section id="demangling-and-dependencies" class="level3">
<h3 class="anchored" data-anchor-id="demangling-and-dependencies">Demangling and dependencies</h3>
<p>Before wrapping up, I did want to poke a little bit more at the shared object files to learn a little more of what is used. For my mac, running the code below demangles the symbols of the shared library and then collects them by C++ namespace and name. Note this just looks at the transpilation module from pyqpanda3.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">nm</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--demangle</span> transpilation.cpython-313-darwin.so <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-2">  <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">awk</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'{print $3}'</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-3">  <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">grep</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'::'</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-4">  <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sed</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'s/(.*//g'</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-5">  <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">awk</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-F</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'::'</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'{print $1"::"$2}'</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span></span>
<span id="cb2-6">  <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">|</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">sort</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-u</span></span></code></pre></div></div>
<p>Most are in <code>QPanda3</code>, but we do see a use of <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page"><code>Eigen</code></a> for linear algebra and <a href="https://github.com/fmtlib/fmt"><code>fmt</code></a> for string formatting. You can also see a bunch of functions like <code>QPanda3::translate_rxx_to_cx_rz_h</code>, which correspond to the built-in gate rewrite rules.</p>
Expand below to see all the symbols.
<details>
<summary>
List of symbols
</summary>
_compute_theta:: _dec_uc_sqg:: calculate_score:: check_gate_connected:: CompilerOriginIR::IRQProgNodeCollectorParser CompilerOriginIR::OriginIRScanner CompilerParser::Parser CompilerParser::Scanner dfs:: Eigen::internal fmt::v11 generateBinarySeries:: generateCombinations:: longest_path_dfs:: modArray:: pybind11::error_already_set QPanda3::amplitude_damping_error QPanda3::BasicTranslationPass QPanda3::block_index_map_key QPanda3::cancellation_map_key QPanda3::ChipBackend QPanda3::CPUAvx2 QPanda3::CPUQVM QPanda3::create_gate QPanda3::DAG QPanda3::DAGNode QPanda3::DAGQCircuit QPanda3::decoherence_error QPanda3::decompose QPanda3::decompose_to_RPhi QPanda3::decomposeTensorProduct QPanda3::DefaultTranspilationPasses QPanda3::depolarizing_error QPanda3::diagonal_decomposition QPanda3::DrawByLayer QPanda3::DrawPicture QPanda3::EquivalenceLibrary QPanda3::GateUnitaryMatrix QPanda3::GateUnitaryMatrixUtils QPanda3::generate_topology QPanda3::get_precessor_single_gates_map QPanda3::get_unitary_matrix QPanda3::get_unitary_matrix_order QPanda3::GetUsedQubits QPanda3::InitPass QPanda3::is_double_gate QPanda3::is_single_gate QPanda3::is_supported_avx2 QPanda3::is_tensor_product QPanda3::isometry_decomposition QPanda3::IsometryDecomposition QPanda3::Karus QPanda3::LayoutPass QPanda3::LinearDepthDecomposition QPanda3::MPS_Tensor QPanda3::NameGenerator QPanda3::NoiseCircuit QPanda3::NoiseModel QPanda3::NoiseUtils QPanda3::OCircuitFusion QPanda3::operator&lt;&lt; QPanda3::OptimizationPass QPanda3::pauli_x_error QPanda3::pauli_y_error QPanda3::pauli_z_error QPanda3::phase_damping_error QPanda3::pre_handle QPanda3::QCircuit QPanda3::QGate QPanda3::QGateImplementation QPanda3::QMeasure QPanda3::QOracle QPanda3::QPandaOptions QPanda3::QProg QPanda3::QProgProcessor QPanda3::QResult QPanda3::QSDecomposition QPanda3::QStateCPU QPanda3::QStateMPS QPanda3::QuantumError QPanda3::QuantumInformation QPanda3::QuantumRegister QPanda3::QuantumState QPanda3::remap_qgate QPanda3::RoutingPass QPanda3::SabrePreLayout QPanda3::SchedulingPass QPanda3::SingletonPermutation QPanda3::task QPanda3::translate_ch_to_cx_h_p QPanda3::translate_cp_to_cx_p QPanda3::translate_crphi_to_oracle QPanda3::translate_crx_to_cx_u1_u3 QPanda3::translate_cry_to_cx_ry QPanda3::translate_crz_to_cx_rz QPanda3::translate_cu1_to_cx_u1 QPanda3::translate_cu2_to_cx_u1_u3 QPanda3::translate_cu3_to_cx_u1_u3 QPanda3::translate_cu4_to_cx_p_u3 QPanda3::translate_cx_to_cp_u3 QPanda3::translate_cx_to_cz_h QPanda3::translate_cx_to_cz_rz_x1 QPanda3::translate_cy_to_cx_p QPanda3::translate_cz_to_cx_h QPanda3::translate_h_to_rx_ry QPanda3::translate_h_to_RZ_X1 QPanda3::translate_h_to_u2 QPanda3::translate_i_to_u1 QPanda3::translate_iswap_to_cx_s_h QPanda3::translate_oracle_to_cz_u4 QPanda3::translate_p_to_RZ QPanda3::translate_p_to_u1 QPanda3::translate_rphi_to_u3 QPanda3::translate_rx_to_rz_x1 QPanda3::translate_rx_to_u3 QPanda3::translate_rxx_to_cx_rz_h QPanda3::translate_ry_to_rz_x1 QPanda3::translate_ry_to_u3 QPanda3::translate_ryy_to_cx_rx_rz QPanda3::translate_rz_to_u1 QPanda3::translate_rzx_to_cx_rz_h QPanda3::translate_rzz_to_cx_rz QPanda3::translate_s_to_RZ QPanda3::translate_s_to_u1 QPanda3::translate_sqiswap_to_cz_rz_x1 QPanda3::translate_swap_to_cx QPanda3::translate_t_to_RZ QPanda3::translate_t_to_u1 QPanda3::translate_u1_to_u3 QPanda3::translate_u2_to_u3 QPanda3::translate_u3_to_rphi_rz QPanda3::translate_u3_to_rx_rz QPanda3::translate_u3_to_u4 QPanda3::translate_u3_to_x1_rz QPanda3::translate_u4_to_u3 QPanda3::translate_u4_to_x1_rz QPanda3::translate_x_to_rx QPanda3::translate_x_to_u3 QPanda3::translate_x_to_x1 QPanda3::translate_x1_to_rphi QPanda3::translate_x1_to_rx QPanda3::translate_y_to_ry QPanda3::translate_y_to_u3 QPanda3::translate_y_to_x1_rz QPanda3::translate_y1_to_rz_x1 QPanda3::translate_z_to_rz QPanda3::translate_z_to_u1 QPanda3::translate_z1_to_rz QPanda3::TranspilationPass QPanda3::Transpiler QPanda3::TwoQubitBasisDecomposer QPanda3::TwoQubitWeylDecomposition QPanda3::uc_decomposition QPanda3::ucry_circuit QPanda3::ucry_decomposition QPanda3::ucrz_decomposition QPanda3::unroll_quantum_circuit QPandaCompiler::QProgNodeCollector std::__1 Utils::convert_int_to_str Utils::convert_uinteger_to_binary Utils::number_to_base_string WriteQCircuitTextFile::get_instance
</details>
</section>
</section>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>The most surprising finding for <code>pyqpanda3</code> is that the vast majority of the runtime (71%) was spent in the <code>convert_qasm_string_to_qprog</code> function parsing the QASM input, not optimizing the circuit. This is due to overhead in its C++ implementation, specifically from using standard library streams and locales, which could be made leaner for a fixed format like QASM.</p>
<p>The actual transpilation is remarkably fast. While it’s closed source, profiling and demangling the library revealed a multi-stage strategy involving a DAG representation, unitary synthesis, and <a href="https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.synthesis.TwoQubitWeylDecomposition">Weyl decomposition</a>. This peek under the hood also showed its reliance on the popular Eigen and fmt libraries. But it would be great to better understand how these steps are combined to give such strong performance!</p>
<p><em>AI Disclaimer</em>: I’ve used LLMs to review and give feedback on this post, but the original content was written by me.</p>


</section>


 ]]></description>
  <guid>https://bachase.github.io/posts/profiling-quantum-compilers-pyqpanda/</guid>
  <pubDate>Wed, 01 Oct 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Profiling Quantum Compilers: pytket</title>
  <link>https://bachase.github.io/posts/profiling-quantum-compilers-pytket/</link>
  <description><![CDATA[ 




<p>For the next post in the quantum compiler profiling <a href="../../posts/profiling-quantum-compilers/">series</a>, we will focus on pytket version 2.9.1. <a href="https://docs.quantinuum.com/tket/api-docs/index.html">pytket</a> is “a python module for interfacing with tket, a quantum computing toolkit and optimising compiler developed by <a href="https://www.quantinuum.com/">Quantinuum</a>.” At the time of writing, Quantinuum just released their next generation quantum software stack, which includes <a href="https://github.com/CQCL/tket2">tket2</a>. But it’s still a work in progress, so for now, I will focus on the existing version.</p>
<section id="overview" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>As we did <a href="../../posts/profiling-quantum-compilers-qiskit">last time</a>, we begin with a top-level view of the compilation. This took a total of 1 minute and 10 seconds. You can inspect this function-aggregated view in speedscope <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fnative.functionagg.profiles%2Fpytket.profile.json&amp;title=Pytket%20Profile%20FunctionAgg">here</a>.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pytket/pytket_overview.png" class="img-fluid"></p>
<p>The benchmark harness code is below, with the code annotated with the labels in the image above. <a id="pytket-python-wrapper"></a></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> run_pytket(qasm):                                               <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#(1)</span></span>
<span id="cb1-2">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> pytket.passes <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> (</span>
<span id="cb1-3">        SequencePass,</span>
<span id="cb1-4">        AutoRebase,</span>
<span id="cb1-5">        FullPeepholeOptimise,</span>
<span id="cb1-6">    )</span>
<span id="cb1-7">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> pytket.predicates <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> CompilationUnit</span>
<span id="cb1-8">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> pytket.circuit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> OpType</span>
<span id="cb1-9">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> pytket.qasm <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> circuit_from_qasm_str</span>
<span id="cb1-10"></span>
<span id="cb1-11">    compilation_unit <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> CompilationUnit(circuit_from_qasm_str(qasm)) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#(2)</span></span>
<span id="cb1-12">    passes <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [</span>
<span id="cb1-13">        FullPeepholeOptimise(),</span>
<span id="cb1-14">        AutoRebase({OpType.Rx, OpType.Ry, OpType.Rz, OpType.CX, OpType.H}),</span>
<span id="cb1-15">    ]</span>
<span id="cb1-16">    SequencePass(passes).<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">apply</span>(compilation_unit)                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#(3)</span></span>
<span id="cb1-17">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> compilation_unit.circuit</span></code></pre></div></div>
<p>The bulk of the time is in two spots:</p>
<div class="no-bullets">
<ul>
<li><span class="circle">2</span> [2%, 1.99s] in <code>circuit_from_qasm_str</code> parsing the 25K line QASM file into pytket’s in-memory circuit representation.</li>
<li><span class="circle">3</span> [96%, 1m 8s] in <code>apply</code> actually optimizing the circuit.</li>
</ul>
</div>
<p>Not visible is the python import time, which at 320ms was less than half a percent of the runtime, but on the same order that Qiskit spends on imports.</p>
<section id="parsing-qasm" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="parsing-qasm">Parsing QASM</h3>
<p>Although a small fraction of the overall runtime, I am curious to explore how tket is parsing QASM and how that compares to other libraries. Zooming in on that segment in the timeline view:</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pytket/pytket_from_json.png" class="img-fluid"></p>
<p>At the highest-level, <span class="circle">1</span> is the <code>circuit_from_qasm_str</code> <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/pytket/pytket/qasm/qasm.py#L995">function</a> in pytket, reproduced here:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> circuit_from_qasm_str(qasm_str: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">str</span>, maxwidth: <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">32</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-&gt;</span> Circuit: <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (1)</span></span>
<span id="cb2-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">global</span> g_parser  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># noqa: PLW0602</span></span>
<span id="cb2-3">    ...</span>
<span id="cb2-4">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#                 (3)             (2)</span></span>
<span id="cb2-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#                  ^               ^</span></span>
<span id="cb2-6">    circ <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Circuit.from_dict(g_parser.parse(qasm_str))</span>
<span id="cb2-7">    cpass <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> scratch_reg_resize_pass(maxwidth) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;-- (4)</span></span>
<span id="cb2-8">    cpass.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">apply</span>(circ)</span>
<span id="cb2-9">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> circ</span></code></pre></div></div>
<p>Here, <code>g_parser</code> is an instance of a <a href="https://github.com/lark-parser/lark">lark</a> parser. Lark is pure-python parser library. The grammar<sup>1</sup> for QASM2 parsing in pytket is <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/pytket/pytket/qasm/grammar.py">here</a>. What is most interesting is <em>what</em> representation tket parses into. The <code>g_parser.parse</code> method at <span class="circle">2</span> takes in a QASM string and returns a python dict that is effectively JSON. Tket has a JSON <a href="https://docs.quantinuum.com/tket/user-guide/manual/manual_circuit.html#importing-exporting-circuits">format for circuits</a> that is uses for serialization. For the QFT circuit we are compiling, this is (mostly) a series of commands, but not at all compact (repeating keys, numeric params as strings); an excerpt:</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Lark is also used in QuEra’s Bloqade circuit dialect for <a href="https://github.com/QuEraComputing/bloqade-circuit/blob/main/src/bloqade/qasm2/parse/qasm2.lark">parsing qasm</a>.</p></div></div><div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb3-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"commands"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"args"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"q"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">99</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]]]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"op"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"type"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Ry"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"params"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"((pi / 2))/pi"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}}</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"args"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"q"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">99</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]]]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"op"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"type"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Rx"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"params"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"(pi)/pi"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}}</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"args"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"q"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">99</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]]]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"op"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"type"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Rz"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"params"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"((pi / 4))/pi"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}}</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"args"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"q"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">99</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]],[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"q"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">98</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]]]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"op"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"type"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"CX"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}}</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"args"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"q"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,[</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">98</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]]]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"op"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:{</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"type"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Rz"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"params"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"(((-pi) / 4))/pi"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}}</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">....</span></span></code></pre></div></div>
<p>As a result, what started as 427 kilobyte QASM file expands to 8.6 megabyte JSON blob!</p>
<p>In <span class="circle">3</span>, the <code>Circuit.from_dict</code> call converts the python dictionary to a JSON string (again overhead!) and ultimately <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Circuit/CircuitJson.cpp#L49">parses it</a> into the in-memory circuit representation. Even though these layers are in C++, there’s just a lot of overhead parsing all those strings (and I imagine was a partial motivation for <a href="https://github.com/unitaryfoundation/jeff">Jeff</a>).</p>
<p>Lastly, in <span class="circle">4</span>, there is a <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/pytket/pytket/passes/resizeregpass.py#L45">pass</a> to ensure all classical registers bit width is below a desired target. I’m guessing this is to better map to hardware, e.g.&nbsp;64-bit classical registers make sense, 774-bit registers don’t.</p>
<p>The take-away I have here is that even transient intermediary representations that might make sense as small scale/for human use (JSON) end up with performance implications at relatively modest scales.</p>
</section>
<section id="compiling" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="compiling">Compiling</h3>
<p>Onwards to the fun stuff.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pytket/pytket_sequence_pass.png" class="img-fluid"></p>
<p>To understand the profile, let’s look back at benchmark harness code. This uses two passes from <code>pytket</code></p>
<div class="no-bullets page-columns page-full">
<ul>
<li><span class="circle">1</span> <a href="https://docs.quantinuum.com/tket/api-docs/passes.html#pytket.passes.FullPeepholeOptimise"><code>FullPeepholeOptimize</code></a> “pass applies Clifford simplifications, commutes single-qubit gates to the front of the circuit and applies passes to squash subcircuits of up to three qubits. This provides a one-size-approximately-fits-all “kitchen sink” solution to Circuit optimisation.” (from <a href="https://docs.quantinuum.com/tket/user-guide/manual/manual_compiler.html#predefined-sequences">docs</a>). <a href="https://en.wikipedia.org/wiki/Peephole_optimization">Peephole optimization</a> is a concept from classical compilers, where you look at small program segments (like looking through a peephole) and locally optimize them. <sup>2</sup></li>
<li><span class="circle">2</span> <code>AutoRebase</code> converts to the target gateset we use in the benchmarks to ensure an apples-to-apples comparison. Note this only took 200ms, so isn’t actually visible on the image above. But I put the label where you’d end up finding it by zooming or Ctrl+F searching for “rebase”.</li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;I suspect the debug symbols get a little messed up, as <code>full_peephole_optimise</code> does show up as 30ms of the call stack, but there are seconds of samples in the underlying passes that I see it calling from the source code. I don’t feel like building locally with full debug symbols, so assuming things map back as you’d expect.</p></div></div></div>
<section id="full-peephole-optimize" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="full-peephole-optimize">Full Peephole Optimize</h4>
<p>Fortunately, there’s a nice <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Transformations/OptimisationPass.cpp#L48">single spot</a> in the C++ source that shows what internal passes full peephole optimization uses. Reproducing here</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1">Transform full_peephole_optimise<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">bool</span> allow_swaps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb4-2">                                OpType target_2qb_gate<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-3">  <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">switch</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>target_2qb_gate<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb4-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">case</span> OpType<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">::</span>CX<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb4-5">      <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span></span>
<span id="cb4-6">          synthesise_tket<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">()</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span> two_qubit_squash<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">false</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span></span>
<span id="cb4-7">          clifford_simp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>allow_swaps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span> synthesise_tket<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">()</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span></span>
<span id="cb4-8">          two_qubit_squash<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>allow_swaps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span> three_qubit_squash<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">()</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span></span>
<span id="cb4-9">          clifford_simp<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span>allow_swaps<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;&gt;</span> synthesise_tket<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">());</span></span>
<span id="cb4-10">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/* snip */</span></span>
<span id="cb4-11">  <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb4-12"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div></div>
<p>By switching to the left-heavy <sup>3</sup> view, we see <code>three_qubit_squash</code> <span class="circle">1</span> is by far the longest running at 52 seconds. The mouse-overed <code>two_qubit_swash</code> <span class="circle">2</span> (which is called twice) runs for 4.5 seconds.</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;Recall, the left-heavy view is not time-ordered, and insteads pushes the longer running segments of the sampled call stack to the left of the chart.</p></div></div><p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pytket/pytket_full_peephole.png" class="img-fluid"></p>
<p>Focusing on <code>three_qubit_squash</code>, it is defined <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Transformations/ThreeQubitSquash.cpp#L311">here</a> in C++, and is also documented as a <a href="https://docs.quantinuum.com/tket/api-docs/passes.html#pytket.passes.ThreeQubitSquash">standalone pass</a></p>
<blockquote class="blockquote">
<p>Squash three-qubit subcircuits into subcircuits having fewer CX gates, when possible, and apply Clifford simplification.</p>
</blockquote>
<p>Looking at the C++ code, it assumes all quantum operations in the circuit are single qubit or CNOT gates. It uses <code>QISystem</code> to track sets of 3-qubit interactions (represented by <code>QInteraction</code>). The pass walks the DAG representation of the circuit in topological order. For each quantum operation, it checks if it overlaps with an existing set of 3-qubit interactions. If so, it combines with them. If its a fresh interaction independent of any prior ones, it starts a new <code>QInteraction</code>. Otherwise, its an operation that would cause an existing <code>QInteraction</code> to exceed 3-qubits (so overlaps with say 1 of the existing 3 qubits). In this cases, it “closes” the interaction, taking the set of gates that had been combined to this interaction and replacing with an equivalent unitary <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Transformations/ThreeQubitSquash.cpp#L109">decomposed</a> to a canonical sequence of a few gates. So in short, contiguous runs of 3-qubit interactions get decomposed to a few gates. This is an interesting comparison to what we saw in the <a href="../../posts/profiling-quantum-compilers-qiskit">Qiskit post</a>, where things like commutative cancellation/re-ordering via algebraic gate identities was the strategy. This <code>pytket</code> pass is more like a synthesis approach.</p>
<p>The <code>close_interaction</code> function doing that synthesis dominates the runtime. From there, time is spent in <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Circuit/ThreeQubitConversion.cpp#L436"><code>three_qubit_synthesis</code></a> (20%) which does a numerical decomposition of three qubit gates and <code>singleq_clifford_sweep()</code> (40%) (care of <code>clifford_simp</code>) which leverages Clifford gate rules to simplify.</p>
<p>My only observation poking around this area is a few lengthy calls to <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Transformations/PQPSquash.cpp#L64"><code>PQPSquasher::flush</code></a>. The <code>PQPSquasher</code> class “squashes chains of single qubit gates to minimal sequences of any two type of rotations (Rx, Ry or Rz), using Euler angle decompositions” (from <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/include/tket/Transformations/PQPSquash.hpp#L28">here</a>). Searching for this in the Sandwhich view of speedscope, I see 15 seconds of CPU time (22% of the entire runtime) here, even though only 110 ms of self-time in that function.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pytket/pqp_flush.png" class="img-fluid"></p>
<p>Further poking in the Callee side of the Sandwich view, I see a bunch of <code>SymEngine::</code> functions, which is a <a href="https://symengine.org/">third-party library</a> for symbolic mathematics, that can be used as a backend for Sympy. For this context, it shows up when merging rotations in the <code>PQPSquasher</code> class (see <code>total_angle</code> in <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Transformations/PQPSquash.cpp#L168"><code>merge_rotations</code></a>). I’m not going to dig much futher, but I’m not suprised there is some overhead for doing symbolic level mathematics. I don’t know if there is any caching or other performance optimization strategies with SymEngine. Perhaps there is a way to disable and switch to floating point calculations instead of that is sufficient for your use case. But it is interesting to the circuits Qiskit and tket generate:</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs"><li class="nav-item"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" aria-controls="tabset-1-1" aria-selected="true" href="">tket</a></li><li class="nav-item"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" aria-controls="tabset-1-2" aria-selected="false" href="">qiskit</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" aria-labelledby="tabset-1-1-tab">
<pre><code>rz(3.998046875*pi) q[91];
cx q[98],q[92];
rz(0.015625*pi) q[93];
cx q[97],q[94];
rz(3.75*pi) q[95];
cx q[99],q[91];
rz(3.9921875*pi) q[92];
cx q[97],q[93];
rz(0.0625*pi) q[94];
cx q[96],q[95];</code></pre>
</div>
<div id="tabset-1-2" class="tab-pane" aria-labelledby="tabset-1-2-tab">
<pre><code>cx q[93],q[92];
rz(-3*pi/4) q[92];
ry(pi/2) q[92];
rz(1.5707933307386703) q[92];
cx q[99],q[91];
rz(-pi/512) q[91];
cx q[99],q[91];
rz(pi/512) q[91];
cx q[98],q[91];
rz(-pi/256) q[91];
</code></pre>
</div>
</div>
</div>
<p>Above are random exceprts of in the middle of the compiled QFT circuit (exported to QASM). Both have single qubit rotation angles that are multiple of <code>pi</code>, but qiskit lagely keeps them as simple fractions (but not all!). tket has them as some floating point multiple of <code>pi</code>. So <code>qiskit</code> must have an faster internal representation that is either symbolic or tracks the fraction representation relative to <code>pi</code>.</p>
</section>
</section>
<section id="a-final-bottoms-up-view" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="a-final-bottoms-up-view">A final Bottoms up view</h3>
<p>One last note on <code>tket</code>, check out the bottom’s up view sorted by self-time</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-pytket/pytket_memory.png" class="img-fluid"></p>
<p>A little over 7 seconds is spent allocating and freeing memory and this is largely in C++ code. This is just a reminder that just using a compiled language is not a guarantee of speed. How you organize your data and use memory has a big impact<sup>4</sup>.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;One drive-by thing I noticed was a use of <code>std::list</code> in the <code>PQPSquash</code> code <a href="https://github.com/CQCL/tket/blob/50f032f630baffa411ef336e3fd14d4f5120c743/tket/src/Transformations/PQPSquash.cpp#L83">here</a>. <code>std::list</code> is a linked list, so each item is a new memory allocation. Although the code does rely on re-ordering/removing elements in the list, I bet a flat memory structure like <code>std::vector</code> wouldn’t be too hard and could perform much better.</p></div></div></section>
</section>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>The vast majority of the runtime was spent in the <code>FullPeepholeOptimise</code> pass, particularly within the <code>three_qubit_squash</code> routine. This pass identifies contiguous blocks of 3-qubit interactions and re-synthesizes them into a more optimal gate sequence. A significant portion of this synthesis time is spent in symbolic math routines for simplifying single-qubit rotations.</p>
<p>Also of note is a 20x size overhead in parsing QASM; the 427 KB input file is first converted into an 8.6 MB JSON representation before being loaded into the final in-memory circuit.</p>
<p>I’m looking forward to seeing what <code>tket2</code> does to improve on these areas!</p>
<p><em>AI Disclaimer</em>: I’ve used LLMs to review and give feedback on this post, but the original content was written by me.</p>


</section>


 ]]></description>
  <guid>https://bachase.github.io/posts/profiling-quantum-compilers-pytket/</guid>
  <pubDate>Mon, 29 Sep 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Profiling Quantum Compilers: Qiskit</title>
  <link>https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/</link>
  <description><![CDATA[ 




<p>This post is the first follow-up in the quantum compiler profiling <a href="../../posts/profiling-quantum-compilers/">series</a>, focusing on Qiskit version 2.1.1. Let’s dive right in!</p>
<section id="overview" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>We begin with a top-level view of the compilation (or transpilation in Qiskit lingo). This took a total of 1.04 seconds. You can inspect this function-aggregated view in speedscope <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fnative.functionagg.profiles%2Fqiskit.profile.json&amp;title=Qiskit%20Profile%20FunctionAgg">here</a>. <img src="https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/qiskit_top_level.png" class="img-fluid"></p>
<p>I’ve labeled the 3 primary calls within the profiling function</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> run_qiskit(qasm):</span>
<span id="cb1-2">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> qiskit <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> QuantumCircuit, transpile <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (1)</span></span>
<span id="cb1-3">    circuit <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> QuantumCircuit.from_qasm_str(qasm) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (2)</span></span>
<span id="cb1-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> transpile(                            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (3)</span></span>
<span id="cb1-5">        circuit, basis_gates<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"rz"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"rx"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ry"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"h"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"cx"</span>], optimization_level<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span></span>
<span id="cb1-6">    )</span></code></pre></div></div>
<div class="no-bullets">
<ul>
<li><span class="circle">1</span> [39%, 410ms] The call tree starting from <code>_find_and_load</code> importing Qiskit.</li>
<li><span class="circle">2</span> [29%, 300ms] in <code>from_qasm_str</code> parsing the 25K line QASM file into Qiskit’s in-memory circuit representation.</li>
<li><span class="circle">3</span> [25%, 260ms] in <code>transpile</code> actually optimizing the circuit.</li>
</ul>
</div>
<p>Let’s dig in a bit more.</p>
<section id="import" class="level3">
<h3 class="anchored" data-anchor-id="import"><code>import</code></h3>
<p>Almost 40% of this run is on imports! I suspect this will be similar for most libraries we profile, as there is a lot of dynamic importing and logic these libraries are doing to support different features, lazily load some more complex dependencies etc. I’m not going to explore which import(s) are taking all this time but a good bit comes from Qiskit itself importing numpy as seen in the sandwich view here: <img src="https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/numpy_import.png" class="img-fluid"></p>
<p>But I do want to highlight this overhead is meaningful for users! For interactive sessions like notebooks you only pay for this once, but in scripts (CI tests etc), you pay for this each time the script is run. This might explain the appeal of languages like Rust, where most of this is resolved at compile time.</p>
<p>For diving deeper, checkout <a href="https://tenthousandmeters.com/blog/python-behind-the-scenes-11-how-the-python-import-system-works/">this</a> old but still solid reference on what Python does when you type <code>from package import foo</code>.</p>
</section>
<section id="parsing-qasm" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="parsing-qasm">Parsing QASM</h3>
<p>Next up is <code>from_qasm_str</code>, which takes 30% of the overall runtime. For this exploration, I switched to the non-function aggregated sampling (speedscope <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fnative.profiles%2Fqiskit.profile.json&amp;title=Qiskit%20Profile">here</a>) because functions like <code>from_bytecode</code> are pretty lengthy. We want to know specifically where inside that function the code is spending time, which is lost with function aggregation. Looking at the sandwich view around <code>from_qasm_str</code> we have some structure</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/loads.png" class="img-fluid"></p>
<p>For <span class="circle">1</span> <code>loads</code> itself is defined in <a href="https://github.com/Qiskit/qiskit/blob/6dd1267466e6effb9b1a60e98ecaae1ac718e5b2/qiskit/qasm2/__init__.py#L578"><code>qasm2/__init__.py</code></a>, reproduced in part here</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> loads(...):</span>
<span id="cb2-2">    custom_instructions <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>(custom_instructions)</span>
<span id="cb2-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> _parse.from_bytecode(</span>
<span id="cb2-4">        _qasm2.bytecode_from_string(</span>
<span id="cb2-5">            string,</span></code></pre></div></div>
<p><code>_qasm2.bytecode_from_string</code> calls directly into Rust to generate some bytecode representation<sup>1</sup> of the parsed QASM that must be easier to manage, and probably is a simpler post-validated representation. But importantly, that call itself doesn’t show up in any samples, so it must be pretty fast.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;<a href="https://en.wikipedia.org/wiki/Bytecode">Bytecode</a> is an instruction set oriented view of a program that simplifies processing by an interpreter. Python itself compiles your code (at execution time) to bytecode before it is run by the Python interpreter. QASM doesn’t have an official bytecode specification, but converting it to bytecode before interpreting is a good strategy to separate parsing + validation from the downstream use.</p></div></div><p>For <span class="circle">2</span> and <span class="circle">3</span>, the samples we have are all in <code>_parse.from_bytecode</code>, where the bytecode is used to construct the in-memory circuit. The two spots are nearby lines <a href="https://github.com/Qiskit/qiskit/blob/6dd1267466e6effb9b1a60e98ecaae1ac718e5b2/qiskit/qasm2/parse.py#L254">here</a></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> op <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> bytecode:</span>
<span id="cb3-2">    ...</span>
<span id="cb3-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> opcode <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> OpCode.Gate:</span>
<span id="cb3-4">            gate_id, parameters, op_qubits <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> op.operands <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (2)</span></span>
<span id="cb3-5">            qc._append(</span>
<span id="cb3-6">                CircuitInstruction(gates[gate_id](<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>parameters),</span>
<span id="cb3-7">                [qubits[q] <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> q <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> op_qubits]) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (3)</span></span>
<span id="cb3-8">            )</span>
<span id="cb3-9">    ...</span></code></pre></div></div>
<p>Look at the functions called from these lines, that first <code>__init__</code> is the initializer for an <code>Rz</code> gate, <code>_append</code> is adding a newly created gate to <code>QuantumCircuit</code>, and <code>params</code> is both setting and adding a parameter to the quantum instruction representing a gate. Almost all the hex addresses <span class="circle">4</span> are calls inside the CPython/libpython shared object file, but I didn’t have debug symbols around to know what they are. But down in <span class="circle">5</span>, we see calls into the Qiskit Rust code to create the Rust instances of these circuit instructions that are then wrapped in Python. I’m not familiar yet with Qiskit internals, but there will always be some overhead to go back and forth to Rust to create each gate instance.</p>
<p>I don’t have any deep insights, but am interested to see the parsing performance of other libraries. It’s also interesting to see the mix of Python and Rust in Qiskit, where the initial bytecode parse is super fast, but there is still work to improve the in-memory construction of circuit representations afterwards.</p>
</section>
<section id="compiling-aka-transpiling" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="compiling-aka-transpiling">Compiling (aka Transpiling)</h3>
<p>Ok, finally showtime! Again, we return to the sandwich view. Note that this is “left-heavy” within the view, meaning the calls show are not time-ordered, but shifted left by longest call.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/transpile.png" class="img-fluid"></p>
<p>Qiskit has a sophisticated <a href="https://quantum.cloud.ibm.com/docs/en/guides/transpile-with-pass-managers">PassManager class</a> for specifying the transpilation passes to run. Our example code here used the default passes with the highest optimization setting. The <code>_run_workflow</code> and <code>execute</code> calls in the callstack are the machinery to dispatch the different passes. But the actual work is done in a specific pass <code>run</code> function. The level 3 passes are defined <a href="https://github.com/Qiskit/qiskit/blob/6dd1267466e6effb9b1a60e98ecaae1ac718e5b2/qiskit/transpiler/preset_passmanagers/level3.py#L27">here</a>, but only two stand out in the profiling results <sup>2</sup>.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Note that the results shown here were sampled at 100 times per second, meaning each sample is 10 milliseconds. This transpile section was ~250ms, so we have 25 samples. The limiting sampling factor was the GitHub workspace machine, which had trouble keeping up at a higher rate (but which I used to get access to native stack trace details). I did run locally with 1000 times per second sampling (but no native symbol support on my Mac), which showed similar time spent in these functions.</p></div></div><section id="minimumpoint" class="level4">
<h4 class="anchored" data-anchor-id="minimumpoint">MinimumPoint</h4>
<p><span class="circle">1</span> is part of the <a href="https://github.com/Qiskit/qiskit/blob/6dd1267466e6effb9b1a60e98ecaae1ac718e5b2/qiskit/transpiler/passes/utils/minimum_point.py#L100"><code>MinimumPoint</code></a> transformation pass. This is used by other iterative passes to see if successive runs have improved some circuit metrics. It was hard to infer what these passes were from the sampled callstacks, so I instead put a breakpoint in the debugger to take a peek when the MinimumPoint class was constructed. I walked up the stack to see the passmanager this is part of and found: <img src="https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/optimization_passes.png" class="img-fluid"> So this pass group is running a bunch of optimization passes, and this <code>MinimumPoint</code> class is checking when it’s converged to a local minimum “best” for depth and size. But the heavy part here is all in one line</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ...</span></span>
<span id="cb4-2"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> score <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> state.score:</span>
<span id="cb4-3">    state.since <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb4-4">    state.score <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> score</span>
<span id="cb4-5">    state.dag <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> deepcopy(dag) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#&lt;-- this one</span></span></code></pre></div></div>
<p>Once a better score is reached, a full copy of the entire DAG is captured. You can scroll below in speedscope to see all the calls this results in.</p>
<p>Given the Python object model, a true independent copy of an object requires copying each internal object as well. This is expensive because Python variables are fundamentally references (pointers) to objects in memory. A simple (or “shallow”) copy of the DAG would just create a new list of pointers to the exact same gate objects. Modifying a gate in the new DAG would also modify it in the old one.</p>
<p><code>deepcopy</code>, in contrast, must recursively walk the entire object graph—visiting every single gate, parameter, and qubit reference—and create a brand-new, independent Python object for each one. This process involves a massive number of new object allocations and reference lookups, all managed by the Python interpreter, making it far slower than a single, contiguous memory copy you might see in a language like C.</p>
<p>For this large circuit, it’s a heavy operation. If the IR were represented in Rust with a less pointer-heavy structure (like a more flat memory layout), it could be possible to optimize this. But I’m guessing this is complex as long as parts of the IR are still managed as Python objects at a granular level, versus entirely represented in Rust.</p>
</section>
<section id="commutative-cancellation" class="level4">
<h4 class="anchored" data-anchor-id="commutative-cancellation">Commutative Cancellation</h4>
<p><span class="circle">2</span> is the other heavy pass spot, with two call stacks corresponding to <code>commutative_cancellation</code> which is (unsurprisingly) a Rust-accelerated pass that uses commutation relations to identify cancellation opportunites between gates. I haven’t tried compiling the Rust components of Qiskit with debug symbols to get the locations within the Rust code directly. But for the longer 30ms call (3 samples), 20 ms (2 samples) are taken when releasing memory in <code>free</code>. In the other, 10 ms (1 sample) of the 20ms are spent hashing, which I assume is a lookup for common gate pairs.</p>
<p>If you look in the time-ordered view you see there are two commutative cancellation pass runs surrounding the minimum point call. Perhaps there could be savings by retaining the analysis or hash lookup across calls.</p>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/commutative_cancel.png" class="img-fluid"></p>
</section>
<section id="extra-extra---qiskit-transpiler-profiling" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="extra-extra---qiskit-transpiler-profiling">Extra Extra - Qiskit Transpiler Profiling</h4>
<p>Qiskit nicely provides a callback hook to capture the impact of various passes, including time spent on passes. This is a nice domain-specific companion to the general profiling results presented here. Running this <a href="https://github.com/bachase/quantum-compiler-profiling/blob/edebf4b8848321cfaec834226f5e5719d2f2fedc/main.py#L10">extra code</a>, we see <sup>3</sup></p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;Qiskit has both analysis passes and transformation passes. The former calculates some properties of the DAG, but doesn’t modify it. The latter does modify it. For simplifying this table, I’ve excluded analysis passes as they didn’t have much runtime in this example.</p></div></div><table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Pass</th>
<th style="text-align: right;">Time (s)</th>
<th style="text-align: right;">Size<sup>4</sup></th>
<th style="text-align: right;">Depth</th>
<th style="text-align: right;">2Q Gates</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">UnitarySynthesis</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">25100</td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">10050</td>
</tr>
<tr class="even">
<td style="text-align: left;">HighLevelSynthesis</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">25100</td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">10050</td>
</tr>
<tr class="odd">
<td style="text-align: left;">BasisTranslator</td>
<td style="text-align: right;">0.0004</td>
<td style="text-align: right;">25100</td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">10050</td>
</tr>
<tr class="even">
<td style="text-align: left;">ElidePermutations</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">25100</td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">10050</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RemoveDiagonalGatesBeforeMeasure</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">25100</td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">10050</td>
</tr>
<tr class="even">
<td style="text-align: left;">RemoveIdentityEquivalent</td>
<td style="text-align: right;">0.0006</td>
<td style="text-align: right;"><strong>15380</strong></td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">10050</td>
</tr>
<tr class="odd">
<td style="text-align: left;">InverseCancellation</td>
<td style="text-align: right;">0.001</td>
<td style="text-align: right;"><strong>8900</strong></td>
<td style="text-align: right;">796</td>
<td style="text-align: right;"><strong>3570</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">ContractIdleWiresInControlFlow</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">8900</td>
<td style="text-align: right;">796</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CommutativeCancellation</td>
<td style="text-align: right;"><strong>0.0118</strong></td>
<td style="text-align: right;"><strong>7289</strong></td>
<td style="text-align: right;"><strong>698</strong></td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">ConsolidateBlocks</td>
<td style="text-align: right;">0.0035</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Split2QUnitaries</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">UnitarySynthesis</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">HighLevelSynthesis</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">BasisTranslator</td>
<td style="text-align: right;">0.0006</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MinimumPoint</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">ConsolidateBlocks</td>
<td style="text-align: right;">0.0035</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">UnitarySynthesis</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">RemoveIdentityEquivalent</td>
<td style="text-align: right;">0.0001</td>
<td style="text-align: right;">7289</td>
<td style="text-align: right;">698</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Optimize1qGatesDecomposition</td>
<td style="text-align: right;">0.0012</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">CommutativeCancellation</td>
<td style="text-align: right;">0.0056</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ContractIdleWiresInControlFlow</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">MinimumPoint</td>
<td style="text-align: right;"><strong>0.0483</strong></td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ConsolidateBlocks</td>
<td style="text-align: right;">0.0035</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">UnitarySynthesis</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RemoveIdentityEquivalent</td>
<td style="text-align: right;">0.0001</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">Optimize1qGatesDecomposition</td>
<td style="text-align: right;">0.0012</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CommutativeCancellation</td>
<td style="text-align: right;">0.0057</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="even">
<td style="text-align: left;">ContractIdleWiresInControlFlow</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MinimumPoint</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">7189</td>
<td style="text-align: right;">696</td>
<td style="text-align: right;">3570</td>
</tr>
</tbody>
</table>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;Size here is the DAG/circuit <a href="https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.dagcircuit.DAGCircuit#size">size</a>, which is the number of instructions.</p></div></div><p>For each column, rows in <strong>bold</strong> had meaningful time duration or change in circuit metric. The most meaningful passes are</p>
<section id="removeidentityequivalent" class="level5">
<h5 class="anchored" data-anchor-id="removeidentityequivalent"><a href="https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.transpiler.passes.RemoveIdentityEquivalent">RemoveIdentityEquivalent</a></h5>
<p>“Removes gates whose effect is close to an identity operation up to a global phase and up to the specified tolerance.” Looking at the QASM, we can directly see many small angle rotations that are close to identity:</p>
<pre><code>rz(pi/2097152);
rz(0) q[14];</code></pre>
<p>This doesn’t change the depth or the number of two qubit gates, but is quite a lot of single qubit gates!</p>
</section>
<section id="inversecancellation" class="level5">
<h5 class="anchored" data-anchor-id="inversecancellation"><a href="https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.transpiler.passes.InverseCancellation">InverseCancellation</a></h5>
<p>“Cancel specific Gates which are inverses of each other when they occur back-to-back.” The only reduction in two-qubit gates! Doing nothing is always easier than doing gates that end up doing nothing! After the prior pass, these opportunities are successive cnots on the same qubits:</p>
<pre><code>cx q[99],q[79];
cx q[99],q[79];</code></pre>
</section>
<section id="commutativecancellation" class="level5">
<h5 class="anchored" data-anchor-id="commutativecancellation"><a href="https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.transpiler.passes.CommutativeCancellation">CommutativeCancellation</a></h5>
<p>“Cancel the redundant (self-adjoint) gates through commutation relations.” This is the first reduction in gate depth and comes from being able to push gates around via commutation relations and then cancel them once close together. There’s not a local QASM excerpt to show for this conveniently. But looking at the Rust <a href="https://github.com/Qiskit/qiskit/blob/d595578b62e10f47b6f2515a9cdd687b898ac9e4/crates/transpiler/src/passes/commutation_cancellation.rs">implementation</a>, it looks like this pass treats each qubit as a wire, and then for commuting sets, pushes gates around into a canonical ordering (when they have well defined commutation relations), after which it then combines or cancels gates, replacing with a consolidated gate.</p>
</section>
</section>
</section>
</section>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>Only a quarter of the runtime was spent in actual transpilation. The rest was in importing Qiskit itself, and parsing the QASM.</p>
<p>You can see the power of the rust Rewrites in e.g.&nbsp;parsing qasm to bytecode. But you can also see the rewrite in progress, where some overhead going back and forth between Python and Rust, and the Python memory model influencing things like copying a DAG.</p>
<p>For transpilation, most <em>time</em> was spent copying the Dag once a fixed point was reached on the optimization pass. By looking at Qiskit specific profiling output via a callback, we saw the few passes that had the largest impact on improvements. Most were applying fairly straightforward simplifications – but those have a big impact on the size, depth and ultimate number of two-qubit gates!</p>
<p>Thanks to <a href="https://nates.place/">Nate</a> for feedback on this post.</p>
<p><em>AI Disclaimer</em>: I’ve used LLMs to review and give feedback on this post, but the original content was written by me.</p>


</section>


 ]]></description>
  <guid>https://bachase.github.io/posts/profiling-quantum-compilers-qiskit/</guid>
  <pubDate>Wed, 10 Sep 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Profiling Quantum Compilers: Introduction</title>
  <link>https://bachase.github.io/posts/profiling-quantum-compilers/</link>
  <description><![CDATA[ 




<p>As part of my work on <a href="https://github.com/unitaryfoundation/ucc"><code>ucc</code></a>, I’ve spent most of my time to date on benchmarking. In the companion repository <a href="https://github.com/unitaryfoundation/ucc-bench"><code>ucc-bench</code></a>, we’ve collected a small suite of representative circuits and built tooling to automate benchmarking performance of quantum compilers, especially as new versions are released.</p>
<p>Recently, my focus has shifted more toward the internals of quantum compilation, and I wanted to get a deeper understanding of how these compilers actually work. I’ve read papers and stepped through code with a debugger, but the performance angle has been nagging at me. We’re seeing a trend of moving core compiler optimization passes to high-performance languages like Rust <sup>1</sup>, so I figured a great way to learn why is to see where today’s compilers spend their time. By profiling a compiler on a benchmark circuit, we can gain insight into both architecture and performance bottlenecks.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Notably <a href="https://medium.com/qiskit/new-weve-started-using-rust-in-qiskit-for-better-performance-a3676433ca8c">Qiskit</a> and <a href="https://github.com/CQCL/tket2">tket</a></p></div></div><p>This is the first post in a series where I’ll explore the performance of quantum compilers by putting them under the profiler.</p>
<section id="profiling-quantum-compilers" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="profiling-quantum-compilers">Profiling Quantum Compilers</h2>
<p>In this post, I briefly introduce profiling Python with the amazing <a href="https://github.com/benfred/py-spy"><code>py-spy</code></a> tool. I won’t go into exhaustive detail on profiling, but I want to provide just enough background (by way of an example) to understand the results in later posts. I’ll also give a brief overview of the repository that contains the code and scripts used to generate the compiler profiling data.</p>
<section id="profiling-and-py-spy" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="profiling-and-py-spy">Profiling and py-spy</h3>
<p>Profiling is the analysis of a program’s execution to understand where it’s spending its resources. For our purposes, we care about one primary resource: time. We want to know which functions are making the compiler slow.</p>
<p><a href="https://github.com/benfred/py-spy"><code>py-spy</code></a> is a fantastic sampling profiler for Python with minimal overhead. It captures a sample of a running program’s call stack at a regular frequency (say 100 times per second). By aggregating thousands of these samples, <code>py-spy</code> builds a statistical picture of where the program spends its time. A crucial feature for our work is the <code>--native</code> flag<sup>2</sup>. This lets <code>py-spy</code> record non-Python parts of the call stack, letting us look inside the compilers that mix Python with native code.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Unfortunately, <code>--native</code> is only <a href="https://www.benfrederickson.com/profiling-native-python-extensions-with-py-spy/">supported</a> on linux/windows and not my Mac :(. That’s why I used Github codespaces below.</p></div></div><section id="an-example" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="an-example">An example</h4>
<p>Let’s look at an example adapted from a <a href="https://yosefk.com/blog/how-profilers-lie-the-cases-of-gprof-and-kcachegrind.html">classic post</a> on how profilers can be misleading. Turns out modern sampling profilers like <code>py-spy</code> handle the issue in that post, but its a good way to explore the visualizations <code>py-spy</code> generates.</p>
<p>Consider this Python script</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> work(n):</span>
<span id="cb1-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># This is a stand-in for a real computational task.</span></span>
<span id="cb1-3">    i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">while</span> i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> n:</span>
<span id="cb1-5">        i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-6"></span>
<span id="cb1-7"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> easy_task():</span>
<span id="cb1-8">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># A task that calls 'work' with a small input.</span></span>
<span id="cb1-9">    work(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100_000</span>)</span>
<span id="cb1-10"></span>
<span id="cb1-11"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> hard_task():</span>
<span id="cb1-12">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># A task that calls 'work' with a much larger input.</span></span>
<span id="cb1-13">    work(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1_000_000</span>)</span>
<span id="cb1-14"></span>
<span id="cb1-15"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> main():</span>
<span id="cb1-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">while</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>:</span>
<span id="cb1-17">        easy_task()</span>
<span id="cb1-18">        hard_task()</span>
<span id="cb1-19"></span>
<span id="cb1-20"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">__name__</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"__main__"</span>:</span>
<span id="cb1-21">    main()</span></code></pre></div></div>
<p>In this code, both <code>easy_task()</code> and <code>hard_task()</code> call the same function, <code>work()</code>, but with vastly different workloads. A simpler profiler that only tracks how much time is spent on specific lines of code would just tell us <code>work()</code> is slow, but not why. A sampling profiler like <code>py-spy</code>, by virtue of collecting the entire call stacks, tells us both where the program is but also how it got there. This means it can distinguish call paths that get to <code>work()</code>, differentiating calls that come by way of <code>easy_task()</code> vs <code>hard_task()</code>.</p>
<p>Let’s see this in action. Assuming the above is saved to a <code>main.py</code>, you would run<sup>3</sup> the command below for a few seconds and then kill the process:</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;On my mac, I need to run this as <code>sudo</code> for <code>py-spy</code> to be able to introspect the running process. I didn’t use <code>--native</code> since this is pure python.</p></div></div><div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">$</span>  py-spy record <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--format</span> speedscope <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-o</span> profile.json <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--function</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--</span> python main.py</span></code></pre></div></div>
<p>Here, we tell <code>py-spy</code> to record a profile of <code>python main.py</code> and save it to the file <code>profile.json</code><sup>4</sup>. It uses the <code>speedscope</code> format, which you can upload to <a href="http://speedscope.app/">http://speedscope.app/</a> to visualize.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;I also passed <code>--function</code> to aggregate samples by the first line number of a function versus the sampled number. This way whether the sample is taken when we are at the <code>i+=1</code> or the <code>while i &lt;n:</code> line in <code>work()</code>, the profile result groups them together. If we didn’t do this, the visualization would end up creating an entry for each distinct line-number of <code>work()</code> sampled and make it harder to analyze the charts.</p></div></div><p>Let’s walk through the speedscope <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fbachase.github.io%2Fposts%2Fprofiling-quantum-compilers%2Fprofile.json&amp;title=Example%20Profile">view</a> of these results:</p>
<section id="time-order-view" class="level5 page-columns page-full">
<h5 class="anchored" data-anchor-id="time-order-view">Time Order View</h5>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers/time_ordered.png" class="img-fluid"> This is the default view when you first load the profile in speedscope. Time flows from left to right, and along the bottom, you see the the call stack at each point in time. So the blue bar with <code>main()</code> covers the entire view, then beneath it you see the alternating calls of <code>hard_task()</code> and <code>easy_task()</code> (although easy is too narrow to see its name!). The width of each box corresponds to the CPU time of that function call<sup>5</sup>. Mousing over a function creates a pop-up with the specific duration and source file for that call. Clicking on a function opens a call-stack view at the bottom, and shows time spent on this specific instance of the function call and aggregate time spent on all such function calls. There’s not a ton more to glean from this simple example, since the code is small enough that we already know a lot about its execution.</p>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;That is, the time spent in that function call and it’s descendant calls. This might be much longer than the time spent actually in that function itself (the self-time) if it mostly calls into other functions.</p></div></div><p>For more complex applications, the time ordered view is a great way to understand the flow of the program, where wider rectangles guide you to the longer running parts of the program. I find it useful to start with this view to confirm your profile captured what you intended, and then to orient yourself around “goldilocks” function calls. These are functions that aren’t super deep in the call stack that its unclear how you got there, but are also not too high-level that they are basically the whole program. Somewhere in the middle is just right.</p>
</section>
<section id="left-heavy-view" class="level5">
<h5 class="anchored" data-anchor-id="left-heavy-view">Left Heavy View</h5>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers/left_heavy.png" class="img-fluid"></p>
<p>The left heavy view throws out the time-ordered aspects, groups similar call stacks together, and then puts the heavier (longest running) stacks to the left of the plot. It has the same mouse-over and click details as the time-order view. Use this view to see where the program is spending its time overall, regardless of the order of execution. For this example, it nicely shows most time in <code>main()</code> is spent on <code>hard_task()</code> vs <code>easy_task()</code>, even though there are corresponding calls to <code>work()</code> below each. This view is useful when there are lots of interleaved function calls but you just care about the aggregate time spent in each alternate.</p>
</section>
<section id="sandwich-view" class="level5">
<h5 class="anchored" data-anchor-id="sandwich-view">Sandwich View</h5>
<p>This last view has two useful aspects. The first is the table in the image above. This shows the total time and self-time spent in a function call, and as a percent of the entire profile result.</p>
<section id="two-times" class="level6">
<h6 class="anchored" data-anchor-id="two-times">Two Times</h6>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers/sandwich.png" class="img-fluid"> Functions with large/large percent of self-time are hotspots to focus on for optimization. Self-time means the CPU is busy working directly in that function, so you can consider zooming in and doing some micro-benchmarking and optimizations on just that function. For our simple example, it nicely shows that the CPU is really spending its time in that silly loop in <code>work()</code>. If that were real code though, finding a way to optimize it would nicely improve overall performance.</p>
<p>Functions with large/large percent of total-time indicate the primary paths of program execution. This is the total CPU time spent where this function was somewhere in the call stack, but not necessarily where the program was running when sampled. So by definition, <code>main()</code> and other high-level functions have large percentages, but that doesn’t really help you understand much. Instead, you would want to scroll down this list to get to the aforementioned goldilocks level. For me, this is when I get to a function and go “huh, I’m surprised it spent that much time here”. For our simple example, we see that <code>hard_task</code> is indeed ten times heavier than <code>easy_task</code>.</p>
</section>
<section id="the-actual-sandwich" class="level6">
<h6 class="anchored" data-anchor-id="the-actual-sandwich">🥪🥪🥪🥪🥪🥪🥪 (the actual sandwich)</h6>
<p><img src="https://bachase.github.io/posts/profiling-quantum-compilers/sandwich-click.png" class="img-fluid"> If you click on a row in this list, you get the sandwich view shown above. This view splits the timeline around that function, effectively filtering the full time-ordered view to just callers and callees of that function. Not suprisingly, this is useful to zoom in on a function and get a sense of where it falls in the program execution. I find this especially useful to understand the architecture of the program.</p>
</section>
</section>
</section>
</section>
<section id="setup" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="setup">Setup</h3>
<p>With that whirlwind tour of profiling behind us, how will we explore quantum compilers? <a href="https://github.com/bachase/quantum-compiler-profiling">https://github.com/bachase/quantum-compiler-profiling</a> is a repository with all you need!</p>
<p>The code uses a 100-qubit QFT circuit in <a href="https://github.com/unitaryfoundation/ucc-bench"><code>ucc-bench</code></a> (by way of <a href="https://github.com/Qiskit/benchpress">benchpress</a> and <a href="https://github.com/pnnl/QASMBench">QASMBench</a>). The script in <code>main.py</code> then transpiles/compiles this circuit via <a href="https://www.ibm.com/quantum/qiskit">Qiskit</a>, <a href="https://github.com/unitaryfoundation/ucc"><code>ucc</code></a>, <a href="https://docs.quantinuum.com/tket/api-docs/index.html">pytket</a>, <a href="https://quantumai.google/cirq">Cirq</a>, or <a href="https://pypi.org/project/pyqpanda3/">pyqpanda3</a>. There’s a corresponding <code>run_bench.sh</code> to generate the profiles using <code>py-spy</code>, and there are sub-directories with some profiles checked in<sup>6</sup>. I generated these profiles under a GitHub codespace (which you can do yourself by forking within GitHub). A tad more detail is in the <code>README</code>, but the upshot is we will use speedscope to explore each compiler’s results in the <a href="https://github.com/bachase/quantum-compiler-profiling/tree/main/native.profiles"><code>native.profiles</code></a> directory in future posts.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;I ran profiles with &amp; without <code>--function</code> to aggregate samples to start of functions. I don’t a priori know much about each function. Some might be lengthy with lots of internal loops, so I’d rather keep samples of different lines separate to potentially identify that structure. But having the aggregated view with <code>--function</code> will also help coarse grain over those details when first analyzing results.</p></div></div><p>The QFT circuit was chosen based in recent <code>ucc-bench</code> <a href="https://github.com/unitaryfoundation/ucc-bench/blob/main/results/ucc-benchmarks-8-core-U22.04/compilation_benchmarks/20250819/20250819125708.eca4a630a31567ea794b1e8f90d5038928110223.compilation.csv">performance results</a>:</p>
<p><a id="benchmark-summary"></a></p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 15%">
<col style="width: 20%">
<col style="width: 19%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Compiler</th>
<th>benchmark_id</th>
<th>raw_multiq_gates</th>
<th>compile_time_ms</th>
<th>compiled_multiq_gates</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ucc</td>
<td>qft</td>
<td>10050</td>
<td>478.4261</td>
<td>2740</td>
</tr>
<tr class="even">
<td>pytket-peep</td>
<td>qft</td>
<td>10050</td>
<td>48776.9968</td>
<td>4498</td>
</tr>
<tr class="odd">
<td>qiskit-default</td>
<td>qft</td>
<td>10050</td>
<td>509.0576</td>
<td>3570</td>
</tr>
<tr class="even">
<td>cirq</td>
<td>qft</td>
<td>10050</td>
<td>32392.2503</td>
<td>4648</td>
</tr>
<tr class="odd">
<td>pyqpanda3</td>
<td>qft</td>
<td>10050</td>
<td>130.838</td>
<td>2740</td>
</tr>
</tbody>
</table>
<p>There is some reduction in two-qubit gates, and the circuit takes a non-trivial amount of compile time. So something interesting is happening!</p>
<p><em>AI Disclaimer</em>: I’ve used LLMs to review and give feedback on this post, but the original content was written by me.</p>


</section>
</section>


 ]]></description>
  <guid>https://bachase.github.io/posts/profiling-quantum-compilers/</guid>
  <pubDate>Thu, 21 Aug 2025 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
