<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-09">

<title>Profiling Quantum Compilers: pyqpanda – bachase notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bachase notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/bachase"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Profiling Quantum Compilers: pyqpanda</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>For the next post in the quantum compiler profiling <a href="../../posts/profiling-quantum-compilers/">series</a>, we will focus on pyqpanda3 version 0.3.1. <a href="https://qcloud.originqc.com.cn/document/qpanda-3/index.html">pyqpanda3</a> is “high-performance quantum programming framework that enhances quantum computing efficiency through optimized circuit compilation, an advanced instruction stream format (OriginBIS), and hardware-aware execution strategies” developed by <a href="https://originqc.com.cn/">OriginQ</a>. Although freely available as a python package, it is closed source with the python code shipping compiled shared object files for supported platforms. I’ve included it because it is very fast and performant on benchmarks, probably thanks to its internal represenation of quantum circuits as a compact binary instruction stream. There are more details in <a href="https://arxiv.org/abs/2504.02455">this</a> arXiv paper from the OriginQ team, but even then, only at a high-level.</p>
<section id="overview" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>As we did the <a href="../../posts/profiling-quantum-compilers-qiskit">last</a> <a href="../../posts/profiling-quantum-compilers-pytket">times</a>, we begin with a top-level view of the compilation. This took a total of 560 milliseconds. Remember, we are sampling 100 times per second, so this is only 56 samples. You can inspect this function-aggregated view in speedscope <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fnative.functionagg.profiles%2Fpyqpanda.profile.json&amp;title=pyqpanda3%20Profile%20FunctionAgg">here</a>.</p>
<p><img src="pyqpanda_overview.png" class="img-fluid"></p>
<p>The benchmark harness code is below, with the code annotated with the labels in the image above.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_pyqpanda(qasm): <span class="co">#                             (1)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> pyqpanda3.intermediate_compiler <span class="im">import</span> (</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        convert_qasm_string_to_qprog,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> pyqpanda3.transpilation <span class="im">import</span> Transpiler</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    circuit <span class="op">=</span> convert_qasm_string_to_qprog(qasm) <span class="co">#    (2)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    transpiler <span class="op">=</span> Transpiler()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transpiler.transpile(                 <span class="co">#    (3)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        circuit,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        init_mapping<span class="op">=</span>{},</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        optimization_level<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        basic_gates<span class="op">=</span>[<span class="st">"RX"</span>, <span class="st">"RY"</span>, <span class="st">"RZ"</span>, <span class="st">"H"</span>, <span class="st">"CNOT"</span>],</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The bulk of the time is in two spots:</p>
<div class="no-bullets">
<ul>
<li><span class="circle">2</span> [71%, 400ms] in <code>convert_qasm_string_to_qprog</code> parsing the 25K line QASM file into pyqpanda3’s in-memory circuit representation.</li>
<li><span class="circle">3</span> [27%, 150ms] in <code>transpile</code> actually optimizing the circuit.</li>
</ul>
</div>
<p>Not visible is the python import time, which was fairly negligible at 10ms. The overall runtime is almost 4 times faster than the next best <a href="../../posts/profiling-quantum-compilers/#benchmark-summary">compiler benchmarked</a> for this QFT circuit.</p>
<section id="parsing" class="level3">
<h3 class="anchored" data-anchor-id="parsing">Parsing</h3>
<p>pyqpanda3 is quite fast, but it’s notable that it spends more time parsing than transpiling the circuit.</p>
<p><img src="./pyqpanda_parse.png" class="img-fluid"></p>
<p>In the sandwich view above, we see what is likely a hand-built parser + tokenizer. The hierarchy of calls to <span class="circle">1</span> show the parser side, where a program is comprised of statements, which can probably be quantum or classical. Our QASM file is all quantum ones that are gate calls with operands. Below those parsers in <span class="circle">2</span> you can see a call to <code>CompilerQASM::QASMScanner::next</code> that pulls out the next token for the parser.</p>
<p>Under the hood this is using C++ standard library streams for this. For example, the <code>CompilerParser::Scanner::consumeNumberLiteral</code> uses a C++ <a href="https://en.cppreference.com/w/cpp/io/basic_stringstream.html"><code>stringstream</code></a> to read into the number. There is some overhead from streams dealing with <a href="https://en.cppreference.com/w/cpp/locale/locale.html"><code>locales</code></a> (also in <span class="circle">3</span> when calling <code>CompilerParser::Token::toString</code>). Specifically, parsing will have to call locale facets (ctype, numpunct, num_get) to classify characters and handle decimal points/thousands separators that may differ by region. Streams and locales also have bookkeeping on whitespace and stream state. These can involve a few layers of indirection (via virtual function dispatch) that are a tad heavy for these short parsing calls. I’m nitpicking here, but given QASM has a specification, you might get more performance here with a leaner/purpose-built parser.</p>
</section>
<section id="transpiling" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="transpiling">Transpiling</h3>
<p>Without the source, it’s even harder to tell what is happening with transpilation, but we at least get a hint from the time-ordered view below<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;When writing this section, I decided to re-run the profiler with a higher sampling rate of 400 times per second because the standard 100 times/second had lots of single sample call stack entries that might not’ve been representative. Click <a href="https://www.speedscope.app/#profileURL=https%3A%2F%2Fraw.githubusercontent.com%2Fbachase%2Fquantum-compiler-profiling%2Frefs%2Fheads%2Fmain%2Fpyqpanda.profiles%2Fpyqpanda.400.profile.json">here</a> to view this version in speedscope. Note there was some impact to runtime as a result, but the relative durations of each phase of transpilation is similar and I prefer slightly more detailed callstacks.</p></div></div><p><img src="./pyqpanda_transpile.png" class="img-fluid"></p>
<p>This timeline view zooms in on the transpilation call, which has three main phases</p>
<div class="no-bullets">
<ul>
<li><span class="circle">1</span> [22.5ms] is <code>DAGQCircuit::from_qprog</code>, which converts from a general representation to a DAG circuit, presumably to be a DAG-style IR for the style of circuit optimizations in pyqpanda.</li>
<li><span class="circle">2</span> [66ms] in <code>Transpiler::transpile</code>. I see calls to <code>OptimizationPass::unitary_synthesis</code>. Of note is a final call to <code>DAGQCircuit::batch_insert</code>, which would potentially help performance by modifying the dag all at once at the end, versus doing it piece by piece as its walked</li>
<li><span class="circle">3</span> [280ms] in <code>BasicTranslationPass::merage_and_translation</code> (typo is in the original binary). Here, I see calls like <code>translate_cz_to_cx_h</code>, <code>translate_oracle_to_cz_u4</code>, <code>translate_u3_to_rx_rz</code>. I also see a stack of calls for <code>TwoQubitBasisDecomposer</code> that has a <code>Weyl</code> decomposition. All of these are repeated a few times, suggesting some looping pass.</li>
</ul>
</div>
<p>Unfortunately, its hard to backout the overall strategy here. The documentation states for this highest level optimization configuration, “advanced optimizations are performed, including matrix optimization, two-qubit gate cancellation, and single-qubit gate merging.” In practice, that looks like some standard translation/substitution rules, and then some consolidation followed by some two-qubit decomposition/synthesis before repeating.</p>
</section>
<section id="demangling-and-dependencies" class="level3">
<h3 class="anchored" data-anchor-id="demangling-and-dependencies">Demangling and dependencies</h3>
<p>Before wrapping up, I did want to poke a little bit more at the shared object files to learn a little more of what is used. For my mac, running the code below demangles the symbols of the shared library and then collects them by C++ namespace and name. Note this just looks at the transpilation module from pyqpanda3.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nm</span> <span class="at">--demangle</span> transpilation.cpython-313-darwin.so <span class="dt">\</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $3}'</span> <span class="dt">\</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">|</span> <span class="fu">grep</span> <span class="st">'::'</span> <span class="dt">\</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">|</span> <span class="fu">sed</span> <span class="st">'s/(.*//g'</span> <span class="dt">\</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">|</span> <span class="fu">awk</span> <span class="at">-F</span><span class="st">'::'</span> <span class="st">'{print $1"::"$2}'</span> <span class="dt">\</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-u</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Most are in <code>QPanda3</code>, but we do see a use of <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page"><code>Eigen</code></a> for linear algebra and <a href="https://github.com/fmtlib/fmt"><code>fmt</code></a> for string formatting. You can also see a bunch of functions like <code>QPanda3::translate_rxx_to_cx_rz_h</code>, which correspond to the built-in gate rewrite rules.</p>
Expand below to see all the symbols.
<details>
<summary>
List of symbols
</summary>
<pre><code>_compute_theta::
_dec_uc_sqg::
calculate_score::
check_gate_connected::
CompilerOriginIR::IRQProgNodeCollectorParser
CompilerOriginIR::OriginIRScanner
CompilerParser::Parser
CompilerParser::Scanner
dfs::
Eigen::internal
fmt::v11
generateBinarySeries::
generateCombinations::
longest_path_dfs::
modArray::
pybind11::error_already_set
QPanda3::amplitude_damping_error
QPanda3::BasicTranslationPass
QPanda3::block_index_map_key
QPanda3::cancellation_map_key
QPanda3::ChipBackend
QPanda3::CPUAvx2
QPanda3::CPUQVM
QPanda3::create_gate
QPanda3::DAG
QPanda3::DAGNode
QPanda3::DAGQCircuit
QPanda3::decoherence_error
QPanda3::decompose
QPanda3::decompose_to_RPhi
QPanda3::decomposeTensorProduct
QPanda3::DefaultTranspilationPasses
QPanda3::depolarizing_error
QPanda3::diagonal_decomposition
QPanda3::DrawByLayer
QPanda3::DrawPicture
QPanda3::EquivalenceLibrary
QPanda3::GateUnitaryMatrix
QPanda3::GateUnitaryMatrixUtils
QPanda3::generate_topology
QPanda3::get_precessor_single_gates_map
QPanda3::get_unitary_matrix
QPanda3::get_unitary_matrix_order
QPanda3::GetUsedQubits
QPanda3::InitPass
QPanda3::is_double_gate
QPanda3::is_single_gate
QPanda3::is_supported_avx2
QPanda3::is_tensor_product
QPanda3::isometry_decomposition
QPanda3::IsometryDecomposition
QPanda3::Karus
QPanda3::LayoutPass
QPanda3::LinearDepthDecomposition
QPanda3::MPS_Tensor
QPanda3::NameGenerator
QPanda3::NoiseCircuit
QPanda3::NoiseModel
QPanda3::NoiseUtils
QPanda3::OCircuitFusion
QPanda3::operator&lt;&lt;
QPanda3::OptimizationPass
QPanda3::pauli_x_error
QPanda3::pauli_y_error
QPanda3::pauli_z_error
QPanda3::phase_damping_error
QPanda3::pre_handle
QPanda3::QCircuit
QPanda3::QGate
QPanda3::QGateImplementation
QPanda3::QMeasure
QPanda3::QOracle
QPanda3::QPandaOptions
QPanda3::QProg
QPanda3::QProgProcessor
QPanda3::QResult
QPanda3::QSDecomposition
QPanda3::QStateCPU
QPanda3::QStateMPS
QPanda3::QuantumError
QPanda3::QuantumInformation
QPanda3::QuantumRegister
QPanda3::QuantumState
QPanda3::remap_qgate
QPanda3::RoutingPass
QPanda3::SabrePreLayout
QPanda3::SchedulingPass
QPanda3::SingletonPermutation
QPanda3::task
QPanda3::translate_ch_to_cx_h_p
QPanda3::translate_cp_to_cx_p
QPanda3::translate_crphi_to_oracle
QPanda3::translate_crx_to_cx_u1_u3
QPanda3::translate_cry_to_cx_ry
QPanda3::translate_crz_to_cx_rz
QPanda3::translate_cu1_to_cx_u1
QPanda3::translate_cu2_to_cx_u1_u3
QPanda3::translate_cu3_to_cx_u1_u3
QPanda3::translate_cu4_to_cx_p_u3
QPanda3::translate_cx_to_cp_u3
QPanda3::translate_cx_to_cz_h
QPanda3::translate_cx_to_cz_rz_x1
QPanda3::translate_cy_to_cx_p
QPanda3::translate_cz_to_cx_h
QPanda3::translate_h_to_rx_ry
QPanda3::translate_h_to_RZ_X1
QPanda3::translate_h_to_u2
QPanda3::translate_i_to_u1
QPanda3::translate_iswap_to_cx_s_h
QPanda3::translate_oracle_to_cz_u4
QPanda3::translate_p_to_RZ
QPanda3::translate_p_to_u1
QPanda3::translate_rphi_to_u3
QPanda3::translate_rx_to_rz_x1
QPanda3::translate_rx_to_u3
QPanda3::translate_rxx_to_cx_rz_h
QPanda3::translate_ry_to_rz_x1
QPanda3::translate_ry_to_u3
QPanda3::translate_ryy_to_cx_rx_rz
QPanda3::translate_rz_to_u1
QPanda3::translate_rzx_to_cx_rz_h
QPanda3::translate_rzz_to_cx_rz
QPanda3::translate_s_to_RZ
QPanda3::translate_s_to_u1
QPanda3::translate_sqiswap_to_cz_rz_x1
QPanda3::translate_swap_to_cx
QPanda3::translate_t_to_RZ
QPanda3::translate_t_to_u1
QPanda3::translate_u1_to_u3
QPanda3::translate_u2_to_u3
QPanda3::translate_u3_to_rphi_rz
QPanda3::translate_u3_to_rx_rz
QPanda3::translate_u3_to_u4
QPanda3::translate_u3_to_x1_rz
QPanda3::translate_u4_to_u3
QPanda3::translate_u4_to_x1_rz
QPanda3::translate_x_to_rx
QPanda3::translate_x_to_u3
QPanda3::translate_x_to_x1
QPanda3::translate_x1_to_rphi
QPanda3::translate_x1_to_rx
QPanda3::translate_y_to_ry
QPanda3::translate_y_to_u3
QPanda3::translate_y_to_x1_rz
QPanda3::translate_y1_to_rz_x1
QPanda3::translate_z_to_rz
QPanda3::translate_z_to_u1
QPanda3::translate_z1_to_rz
QPanda3::TranspilationPass
QPanda3::Transpiler
QPanda3::TwoQubitBasisDecomposer
QPanda3::TwoQubitWeylDecomposition
QPanda3::uc_decomposition
QPanda3::ucry_circuit
QPanda3::ucry_decomposition
QPanda3::ucrz_decomposition
QPanda3::unroll_quantum_circuit
QPandaCompiler::QProgNodeCollector
std::__1
Utils::convert_int_to_str
Utils::convert_uinteger_to_binary
Utils::number_to_base_string
WriteQCircuitTextFile::get_instance</code></pre>
</details>
</section>
</section>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>The most surprising finding for <code>pyqpanda3</code> is that the vast majority of the runtime (71%) was spent in the <code>convert_qasm_string_to_qprog</code> function parsing the QASM input, not optimizing the circuit. This is due to overhead in its C++ implementation, specifically from using standard library streams and locales, which could be made leaner for a fixed format like QASM.</p>
<p>The actual transpilation is remarkably fast. While it’s closed source, profiling and demangling the library revealed a multi-stage strategy involving a DAG representation, unitary synthesis, and <a href="https://quantum.cloud.ibm.com/docs/en/api/qiskit/qiskit.synthesis.TwoQubitWeylDecomposition">Weyl decomposition</a>. This peek under the hood also showed its reliance on the popular Eigen and fmt libraries. But it would be great to better understand how these steps are combined to give such strong performance!</p>
<p><em>AI Disclaimer</em>: I’ve used LLMs to review and give feedback on this post, but the original content was written by me.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/bachase\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>