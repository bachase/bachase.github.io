[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "notes",
    "section": "",
    "text": "Date\n\n\n\nTitle\n\n\n\n\n\n\n\n\n¬†\n\n\nProfiling Quantum Compilers: Introduction\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/profiling-quantum-compilers/index.html",
    "href": "posts/profiling-quantum-compilers/index.html",
    "title": "Profiling Quantum Compilers: Introduction",
    "section": "",
    "text": "As part of my work on ucc, I‚Äôve spent most of my time to date on benchmarking. In the companion repository ucc-bench, we‚Äôve collected a small suite of representative circuits and built tooling to automate profiling of quantum compilers, especially as new versions are released.\nRecently, my focus has shifted more toward the internals of quantum compilation, and I wanted to get a deeper understanding of how these compilers actually work. I‚Äôve read papers and stepped through code with a debugger, but the performance angle has been nagging at me. We‚Äôre seeing a trend of moving core compiler optimization passes to high-performance languages like Rust 1, so I figured a great way to learn why is to see where today‚Äôs compilers spend their time. By profiling a compiler on a benchmark circuit, we can gain insight into both architecture and performance bottlenecks.\nThis is the first post in a series where I‚Äôll explore the performance of quantum compilers by putting them under the profiler."
  },
  {
    "objectID": "posts/profiling-quantum-compilers/index.html#profiling-quantum-compilers",
    "href": "posts/profiling-quantum-compilers/index.html#profiling-quantum-compilers",
    "title": "Profiling Quantum Compilers: Introduction",
    "section": "Profiling Quantum Compilers",
    "text": "Profiling Quantum Compilers\nIn this post, I briefly introduce profiling Python with the amazing py-spy tool. I won‚Äôt go into exhaustive detail on profiling, but I want to provide just enough background (by way of an example) to understand the results in later posts. I‚Äôll also give a brief overview of the repository that contains the code and scripts used to generate the compiler profiling data.\n\nProfiling and py-spy\nProfiling is the analysis of a program‚Äôs execution to understand where it‚Äôs spending its resources. For our purposes, we care about one primary resource: time. We want to know which functions are making the compiler slow.\npy-spy is a fantastic sampling profiler for Python with minimal overhead. It captures a sample of a running program‚Äôs call stack at a regular frequency (say 100 times per second). By aggregating thousands of these samples, py-spy builds a statistical picture of where the program spends its time. A crucial feature for our work is the --native flag2. This lets py-spy record non-Python parts of the call stack, letting us look inside the compilers that mix Python with native code.\n2¬†Unfortunately, --native is only supported on linux/windows and not my Mac :(. That‚Äôs why I used Github codespaces below.\nAn example\nLet‚Äôs look at an example adapted from a classic post on how profilers can be misleading. Turns out modern sampling profilers like py-spy handle the issue in that post, but its a good way to explore the visualizations py-spy generates.\nConsider this Python script\ndef work(n):\n    # This is a stand-in for a real computational task.\n    i = 0\n    while i &lt; n:\n        i += 1\n\ndef easy_task():\n    # A task that calls 'work' with a small input.\n    work(100_000)\n\ndef hard_task():\n    # A task that calls 'work' with a much larger input.\n    work(1_000_000)\n\ndef main():\n    while True:\n        easy_task()\n        hard_task()\n\nif __name__ == \"__main__\":\n    main()\nIn this code, both easy_task() and hard_task() call the same function, work(), but with vastly different workloads. A simpler profiler that only tracks how much time is spent on specific lines of code would just tell us work() is slow, but not why. A sampling profiler like py-spy, by virtue of collecting the entire call stacks, tells us both where the program is but also how it got there. This means it can distinguish call paths that get to work(), differentiating calls that come by way of easy_task() vs hard_task().\nLet‚Äôs see this in action. Assuming the above is saved to a main.py, you would run3 the command below for a few seconds and then kill the process:\n3¬†On my mac, I need to run this as sudo for py-spy to be able to introspect the running process. I didn‚Äôt use --native since this is pure python.$  py-spy record --format speedscope -o profile.json --function -- python main.py\nHere, we tell py-spy to record a profile of python main.py and save it to the file profile.json4. It uses the speedscope format, which you can upload to http://speedscope.app/ to visualize.\n4¬†I also passed --function to aggregate samples by the first line number of a function versus the sampled number. This way whether the sample is taken when we are at the i+=1 or the while i &lt;n: line in work(), the profile result groups them together. If we didn‚Äôt do this, the visualization would end up creating an entry for each distinct line-number of work() sampled and make it harder to analyze the charts.Let‚Äôs walk through the speedscope view of these results:\n\nTime Order View\n This is the default view when you first load the profile in speedscope. Time flows from left to right, and along the bottom, you see the the call stack at each point in time. So the blue bar with main() covers the entire view, then beneath it you see the alternating calls of hard_task() and easy_task() (although easy is too narrow to see its name!). The width of each box corresponds to the CPU time of that function call5. Mousing over a function creates a pop-up with the specific duration and source file for that call. Clicking on a function opens a call-stack view at the bottom, and shows time spent on this specific instance of the function call and aggregate time spent on all such function calls. There‚Äôs not a ton more to glean from this simple example, since the code is small enough that we already know a lot about its execution.\n5¬†That is, the time spent in that function call and it‚Äôs descendant calls. This might be much longer than the time spent actually in that function itself (the self-time) if it mostly calls into other functions.For more complex applications, the time ordered view is a great way to understand the flow of the program, where wider rectangles guide you to the longer running parts of the program. I find it useful to start with this view to confirm your profile captured what you intended, and then to orient yourself around ‚Äúgoldilocks‚Äù function calls. These are functions that aren‚Äôt super deep in the call stack that its unclear how you got there, but are also not too high-level that they are basically the whole program. Somewhere in the middle is just right.\n\n\nLeft Heavy View\n\nThe left heavy view throws out the time-ordered aspects, groups similar call stacks together, and then puts the heavier (longest running) stacks to the left of the plot. It has the same mouse-over and click details as the time-order view. Use this view to see where the program is spending its time overall, regardless of the order of execution. For this example, it nicely shows most time in main() is spent on hard_task() vs easy_task(), even though there are corresponding calls to work() below each. This view is useful when there are lots of interleaved function calls but you just care about the aggregate time spent in each alternate.\n\n\nSandwich View\n\nThis last view has two useful aspects. The first is the table in the image above. This shows the total time and self-time spent in a function call, and as a percent of the entire profile result.\n\nTwo Times\nFunctions with large/large percent of self-time are hotspots to focus on for optimization. Self-time means the CPU is busy working directly in that function, so you can consider zooming in and doing some micro-benchmarking and optimizations on just that function. For our simple example, it nicely shows that the CPU is really spending its time in that silly loop in work(). If that were real code though, finding a way to optimize it would nicely improve overall performance.\nFunctions with large/large percent of total-time indicate the primary paths of program execution. This is the total CPU time spent where this function was somewhere in the call stack, but not necessarily where the program was running when sampled. So by definition, main() and other high-level functions have large percentages, but that doesn‚Äôt really help you understand much. Instead, you would want to scroll down this list to get to the aforementioned goldilocks level. For me, this is when I get to a function and go ‚Äúhuh, I‚Äôm surprised it spent that much time here‚Äù. For our simple example, we see that hard_task is indeed ten times heavier than easy_task.\n\n\nü•™ü•™ü•™ü•™ü•™ü•™ü•™ (the actual sandwich)\n If you click on a row in this list, you get the sandwich view shown above. This view splits the timeline around that function, effectively filtering the full time-ordered view to just callers and callees of that function. Not suprisingly, this is useful to zoom in on a function and get a sense of where it falls in the program execution. I find this especially useful to understand the architecture of the program.\n\n\n\n\n\nSetup\nWith that whirlwind tour of profiling behind us, how will we explore quantum compilers? https://github.com/bachase/quantum-compiler-profiling is a repository with all you need!\nThe code uses a 100-qubit QFT circuit in ucc-bench (by way of benchpress and QASMBench). The script in main.py then transpiles/compiles this circuit via Qiskit, ucc, pytket, Cirq, or pyqpanda3. There‚Äôs a corresponding run_bench.sh to run 6 and generate the profiles using py-spy, and there are sub-directories with some profiles checked in. I generated these profiles under a GitHub codespace (which you can do yourself by forking within GitHub). A tad more detail is in the README, but the upshot is we will use speedscope to explore each compiler‚Äôs results in the native.profiles directory in future posts.\n6¬†Unlike the example in this post, I did not use --function to aggregate samples to start of functions. I might go back and do so, but I don‚Äôt a priori know much about each function. Some might be lengthy with lots of loops, so I‚Äôd rather keep samples of different lines separate to potentially identify that structure.AI Disclaimer: I‚Äôve used LLMs to review and give feedback on this post, but the original content was written by me."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "notes for myself on things I‚Äôm learning about"
  }
]